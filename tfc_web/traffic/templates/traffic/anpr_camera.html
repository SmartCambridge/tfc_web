{% extends "base.html" %}
{% load static %}
{% block head %}
    {% include 'leaflet_snippet.html' %}
    <script type="text/javascript" src="{% static 'js/leaflet.polylineDecorator.js' %}"></script>
    <link rel="stylesheet" href="{% static 'map.css' %}" />
    <script src="{% static 'js/nouislider.min.js' %}"></script>
    <link rel="stylesheet" href="{% static 'nouislider.min.css' %}" />
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <style>
        .noUi-horizontal .noUi-tooltip {
            bottom: -40px;
        }
        .mdl-switch.is-checked .mdl-switch__track {
            background: rgba(7, 142, 54, 0.5);
        }
        .mdl-switch.is-disabled .mdl-switch__track {
            background: rgba(0, 0, 0, 0.25);
        }
        .mdl-switch.is-checked .mdl-switch__thumb {
            background: #00b2b6;
        }
        .mdl-switch.is-disabled .mdl-switch__thumb {
            background: #989a9a;
        }
    </style>
{% endblock %}
{% block inner_content %}
    <div class="mdl-grid">
        <div class="mdl-cell mdl-cell--12-col">
            <h3 style="margin-left: 20px; margin-bottom: 10px;">Traffic flow</h3>
        </div>
        <div class="mdl-cell mdl-cell--9-col mdl-cell--8-col-tablet mdl-cell--4-col-phone" style="margin-bottom: 40px;">
            <div id="map" style="height: 75vh; width: 100%; min-height: 500px;"></div>
            <div id="slider-date" class="noUi-target noUi-ltr noUi-horizontal" style="margin: 10px 50px"></div>
        </div>
        <div class="mdl-cell mdl-cell--3-col mdl-cell--8-col-tablet mdl-cell--4-col-phone">
            <p style="margin-bottom: 30px">
                This map shows the transit flow for each one of the traffic cameras in the map. When a camera is clicked,
                the map shows all the transit going through that camera. You can use the From/To toggle to show traffic
                incoming or traffic outgoing from the selected camera. The opacity of the lines show hou much traffic
                flow there is between cameras. If you select two cameras, the map will show you how much traffic goes
                between the two cameras in a specific direction (from the Origin to the Destination camera).
                There is a slider you can use to select the time range (from selected to +1 hour) and the day that you
                want to explore. The graph will also update showing the flow chart for the whole day.
                <br><img src="{% static 'images/camera.png' %}" style="width: 20px;height: 20px;"> ANPR Camera
                <br><img src="{% static 'images/camera_origin_selected.png' %}" style="width: 20px;height: 20px;"> ANPR Origin Camera
                <br><img src="{% static 'images/camera_destination_selected.png' %}" style="width: 20px;height: 20px;"> ANPR Destination Camera
                <br>
                <label class="mdl-switch mdl-js-switch mdl-js-ripple-effect" for="from-to-switch">
                    <input type="checkbox" id="from-to-switch" class="mdl-switch__input">
                    <span class="mdl-switch__label">From / To</span>
                </label>
            </p>
            <div id="chart" style="width: 100%;">
                <svg></svg>
            </div>
        </div>
    </div>
    <script>
        var map = L.map('map').setView({{ mapcenter|default:"[52.205, 0.119], 13" }});
        var info_map = L.control();
        var urlparams = new URLSearchParams(window.location.search);
        var dateSlider;
        var trips = JSON.parse('{{ trips|safe }}');
        var stats = JSON.parse('{{ stats|safe }}');
        var total_stats = JSON.parse('{{ total_stats|safe }}');
        var trip_convinations = {};
        var camera_origin_selected;
        var camera_destination_selected;
        var from_to_switch = document.querySelector('#from-to-switch');
        var cameras = {{% for camera in cameras %}
            "{{ camera.id }}": {
                "lat": "{{ camera.lat }}",
                "lng": "{{ camera.lng }}",
                "desc": "{{ camera.description }}",
                "units": {{ camera.units }}
            },
        {% endfor %}};
        var current_time = timestamp('2017-06-12 08:00 GMT+1');

        var cameraIcon = L.icon({
            iconUrl: '{% static 'images/camera.png' %}',
            iconSize: [20, 20]
        });

        var cameraOriginSelectedIcon = L.icon({
            iconUrl: '{% static 'images/camera_origin_selected.png' %}',
            iconSize: [20, 20]
        });

        var cameraDestinationSelectedIcon = L.icon({
            iconUrl: '{% static 'images/camera_destination_selected.png' %}',
            iconSize: [20, 20]
        });

        /************* This is the code of the stats graph *****************/
        function statsdata() {
            var statsdata = [];
            var i;
            if (stats.length !== 0) {
                var legend_text;
                if (camera_destination_selected !== undefined)
                    legend_text = 'Traffic between selected cameras';
                else
                    legend_text = 'Traffic from selected camera';
                statsdata.push(['Date and Time', legend_text]);
                for (i = 0; i < total_stats.length; i++) {
                    statsdata.push([new Date(total_stats[i].time), stats[i].num]);
                }
            } else {
                statsdata.push(['Date and Time', 'Traffic from all cameras']);
                for (i = 0; i < total_stats.length; i++) {
                    statsdata.push([new Date(total_stats[i].time), total_stats[i].num]);
                }

            }
            return statsdata;
        }

        google.charts.load('current', {'packages':['corechart']});
        google.charts.setOnLoadCallback(drawChart);

        function drawChart() {
            var data = google.visualization.arrayToDataTable(statsdata());
            var options = {
                title: 'Traffic on ' + new Date(current_time * 1000).toDateString(),
                curveType: 'function',
                legend: { position: 'bottom' },
                vAxis: { minValue: 0 }
            };
            var chart = new google.visualization.LineChart(document.getElementById('chart'));
            chart.draw(data, options);
        }
        /******* This is the END of the stats code for the graph **********/

        function clearMap() {
            var i;
            for(i in map._layers)
                if ((map._layers[i]._path !== undefined) || (map._layers[i]._paths !== undefined))
                    map.removeLayer(map._layers[i]);
        }

        function drawFlow() {
            trip_convinations = {};
            var from = document.getElementById("from-to-switch").checked;
            var z, key, ti, tei, max_weight;
            if (camera_origin_selected !== undefined) {
                for (var i = 0; i < trips.length; i++) {
                    // From the camera selected (we have to discard previous trip)
                    // The index should start from where the camera selected is in the trip
                    ti = trips[i].chain_vector.indexOf(camera_origin_selected.options['cameraid']);
                    if (camera_destination_selected !== undefined) {
                        // The index should end at position the destination camera selected is in the trip
                        tei = trips[i].chain_vector.indexOf(camera_destination_selected.options['cameraid']);
                        if ((ti > -1) && (tei > -1) && (tei > ti)) {
                            for (z = ti; z < tei; z++) {
                                key = trips[i].chain_vector[z] + "," + trips[i].chain_vector[z + 1];
                                if (key in trip_convinations)
                                    trip_convinations[key]++;
                                else
                                    trip_convinations[key] = 1;
                            }
                        }
                    } else {
                        if (ti > -1) {
                            if (from === false) {
                                for (z = ti; z < trips[i].chain_vector.length - 1; z++) {
                                    key = trips[i].chain_vector[z] + "," + trips[i].chain_vector[z + 1];
                                    if (key in trip_convinations)
                                        trip_convinations[key]++;
                                    else
                                        trip_convinations[key] = 1;
                                }
                            } else {
                                for (z = 0; z <= ti - 1; z++) {
                                    key = trips[i].chain_vector[z] + "," + trips[i].chain_vector[z + 1];
                                    if (key in trip_convinations)
                                        trip_convinations[key]++;
                                    else
                                        trip_convinations[key] = 1;
                                }
                            }
                        }
                    }
                }
            }
            clearMap();

            max_weight = Math.max(...Object.values(trip_convinations));

            var list_of_links = [];
            var sorted_trips = [];
            for (var trip_key in trip_convinations) {
                sorted_trips.push([trip_key, trip_convinations[trip_key]]);
            }
            sorted_trips.sort(function(a, b) {
                return a[1] - b[1];
            });
            sorted_trips.forEach(function(item) {
                var camerasi = item[0].split(",");
                var camera1 = parseInt(camerasi[0]);
                var camera2 = parseInt(camerasi[1]);
                if (camera1 !== 35 && camera2 !== 35 && camera1 !== 96 && camera2 !== 96 && item[1] > 4) {
                    var latlngs;
                    if (list_of_links.includes(camera2+","+camera1)) {
                        latlngs = [
                            [(parseFloat(cameras[camera1].lat) + 0.00005).toString(),
                                (parseFloat(cameras[camera1].lng) + 0.00005).toString()],
                            [(parseFloat(cameras[camera2].lat) + 0.00005).toString(),
                                (parseFloat(cameras[camera2].lng) + 0.00005).toString()]
                        ]
                    } else {
                        latlngs = [
                            [cameras[camera1].lat, cameras[camera1].lng],
                            [cameras[camera2].lat, cameras[camera2].lng]
                        ]
                    }
                    // red = 240 vehicles / hour
                    var occupancy = ((item[1]/240) > 1) ? 1 : (item[1]/240);
                    var hue = ((1-occupancy)*120).toString(10);
                    var color = ["hsl(",hue,",75%,50%)"].join("");
                    info_map.update("Maximum opacity: "+max_weight.toString());
                    var line = L.polyline(latlngs, {weight: 5, color: color, lineCap: "butt"}).bindTooltip(
                        item[1].toString() + " vehicles", {sticky: true}).addTo(map);
                    L.polylineDecorator(line, {
                        patterns: [
                            {
                                offset: '100%',
                                repeat: 0,
                                symbol: L.Symbol.arrowHead(
                                    {
                                        pixelSize: 15,
                                        polygon: false,
                                        pathOptions: {
                                            stroke: true,
                                            color: color
                                        }
                                    }
                                )
                            }
                        ]
                    }).addTo(map);
                    list_of_links.push(camera1+","+camera2);
                }
            });
        }

        function cameraMarkerOnClick(e) {
            {# There is an origin camera selected #}
            if (camera_origin_selected !== undefined) {
                {# User is deactivating the origin camera so we deselect origin and destiny #}
                if (camera_origin_selected === e.target) {
                    {# If it was a destiantion camera selected revert its icon back to normal #}
                    if (camera_destination_selected !== undefined) {
                        camera_destination_selected.setIcon(cameraIcon);
                        camera_destination_selected = undefined;
                    }
                    camera_origin_selected.setIcon(cameraIcon);
                    camera_origin_selected = undefined;
                } else {
                    if (camera_destination_selected !== undefined) {
                        camera_destination_selected.setIcon(cameraIcon);
                        if (camera_destination_selected === e.target) {
                            camera_destination_selected = undefined;
                        } else {
                            camera_destination_selected = e.target;
                            camera_destination_selected.setIcon(cameraDestinationSelectedIcon);
                        }
                    } else {
                        camera_destination_selected = e.target;
                        camera_destination_selected.setIcon(cameraDestinationSelectedIcon);
                    }
                }
                {# User is selecting a new destination camera #}
            } else {
                {# There isn't any origin camera selected #}
                camera_origin_selected = e.target;
                camera_origin_selected.setIcon(cameraOriginSelectedIcon);
            }
            if ((camera_origin_selected !== undefined) && (camera_destination_selected !== undefined)) {
                from_to_switch.disabled = true;
                from_to_switch.parentElement.classList.add("is-disabled");
            } else {
                from_to_switch.disabled = false;
                from_to_switch.parentElement.classList.remove("is-disabled");
            }
            retrieve_flowdata();
        }

        function retrieve_flowdata() {
            var camera_origin_id = camera_origin_selected && camera_origin_selected.options &&
                camera_origin_selected.options.cameraid || "";
            var camera_destination_id = camera_destination_selected && camera_destination_selected.options &&
                camera_destination_selected.options.cameraid || "";
            if (camera_destination_id !== "") {
                camera_destination_id = "&camera_destination_id=" + camera_destination_id;
            }
            if (camera_origin_id !== "") {
                camera_origin_id = "&camera_origin_id=" + camera_origin_id;
            }
            var url = '{% url 'anpr_map_json' %}?datetime=' + current_time.toString() + camera_origin_id +
                camera_destination_id;
            $.ajax({
                url: url,
                dataType: 'application/json',
                beforeSend: function(){
                    dateSlider.setAttribute('disabled', true);
                },
                complete: function (data) {
                    dateSlider.removeAttribute('disabled');
                    trips = JSON.parse(data.responseText)['trips'];
                    stats = JSON.parse(data.responseText)['stats'];
                    total_stats = JSON.parse(data.responseText)['total_stats'];
                    drawFlow();
                    drawChart();
                }
            });
        }

        // Create a new date from a string, return as a timestamp.
        function timestamp(str) {
            return new Date(str).getTime()/1000;
        }

        // Create a string representation of the date.
        function formatDate(idate) {
            var date = new Date(+idate*1000);
            return date.toString();
        }

        $(document).ready(function() {
            L.tileLayer('https://{s}.tile.osm.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://osm.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            info_map.onAdd = function (map) {
                    this._div = L.DomUtil.create('div', 'leaflet-control-attribution leaflet-control');
                    this.update();
                    return this._div;
            };
            // method that we will use to update the control based on feature properties passed
            info_map.update = function (info_text) {
                this._div.innerHTML = info_text;
            };
            info_map.addTo(map);

            Object.keys(cameras).forEach(function(key) {
                L.marker([cameras[key].lat, cameras[key].lng], {"icon": cameraIcon, "cameraid": key})
                    .bindTooltip(cameras[key].desc + "<br>Latitude: " + cameras[key].lat + "<br>Longitude: " + cameras[key].lng, {sticky: true})
                    .addTo(map).on('click', cameraMarkerOnClick);
            });

            /************* This is the START of the date slider code **************/
            dateSlider = document.getElementById('slider-date');

            noUiSlider.create(dateSlider, {
                // Create two timestamps to define a range.
                range: {
                    min: timestamp('2017-06-11 00:00'),
                    max: timestamp('2017-06-18 00:00')
                },

                // Steps of one hour
                step: 60 * 60,

                // Two more timestamps indicate the handle starting positions.
                start: [timestamp('2017-06-11 08:00')],

                tooltips: [true],

                format: { to: formatDate, from: Number }
            });

            dateSlider.noUiSlider.on('set', function (values, handle) {
                current_time = timestamp(values[0]);
                retrieve_flowdata();
            });
            /************* This is the END of the date slider code **************/

            drawChart();
        });

        $(window).resize(function(){
            drawChart();
        });

        $('#from-to-switch').change(function(){
            drawFlow();
        });
    </script>
{% endblock %}
